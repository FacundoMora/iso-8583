package types_test

import (
	"bytes"
	"testing"

	"github.com/mercadolibre/iso-8583/serdes"
	"github.com/mercadolibre/iso-8583/types"

	"github.com/stretchr/testify/assert"
)

func TestBerTLV_SerializeDeserialize(t *testing.T) {
	tests := []struct {
		name    string
		data    serdes.Value
		taipe   serdes.Serdes
		want    *bytes.Buffer
		wantErr bool
	}{
		{
			name: "serialize and deserialize inception tag ok",
			taipe: types.BerTLV{
				Items: []types.Field{
					{Name: "67", SerDes: types.BerTLV{
						Items: []types.Field{
							{Name: "bf0c", SerDes: types.Ebcdic{}},
							{Name: "4f", SerDes: types.Ebcdic{}},
							{Name: "5f", SerDes: types.Ebcdic{}},
						}},
					},
				},
			},
			data:    map[string]interface{}{"67": map[string]interface{}{"bf0c": "032", "4f": "12345"}},
			want:    bytes.NewBuffer([]byte{0x67, 0xd, 0xbf, 0xc, 0x3, 0xf0, 0xf3, 0xf2, 0x4f, 0x5, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5}),
			wantErr: false,
		},
		{
			name: "serialize and deserialize with fixed size len",
			taipe: types.BerTLV{SizeLen: 2, Items: []types.Field{
				{
					Name:   "bf0c",
					SerDes: types.Ebcdic{},
				},
			}},
			data:    map[string]interface{}{"bf0c": "032"},
			want:    bytes.NewBuffer([]byte{0xbf, 0xc, 0x0, 0x3, 0xf0, 0xf3, 0xf2}),
			wantErr: false,
		},
		{
			name: "serialize and deserialize multiple tag ok",
			taipe: types.BerTLV{Items: []types.Field{
				{
					Name:   "bf0c",
					SerDes: types.Ebcdic{},
				},
				{
					Name:   "4f",
					SerDes: types.Ebcdic{},
				},
			}},
			data:    map[string]interface{}{"bf0c": "032", "4f": "12345"},
			want:    bytes.NewBuffer([]byte{0xbf, 0xc, 0x3, 0xf0, 0xf3, 0xf2, 0x4f, 0x5, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5}),
			wantErr: false,
		},
		{
			name: "serialize and deserialize len size one byte ok",
			taipe: types.BerTLV{Items: []types.Field{
				{
					Name:   "4f",
					SerDes: types.Ebcdic{},
				},
				{
					Name:   "02",
					SerDes: types.Ebcdic{},
				},
			}},
			data:    map[string]interface{}{"4f": "032", "02": "612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456"},
			want:    bytes.NewBuffer([]byte{0x4f, 0x3, 0xf0, 0xf3, 0xf2, 0x2, 0x7e, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6}),
			wantErr: false,
		},
		{
			name: "serialize and deserialize len size two bytes ok",
			taipe: types.BerTLV{Items: []types.Field{
				{
					Name:   "4f",
					SerDes: types.Ebcdic{},
				},
				{
					Name:   "02",
					SerDes: types.Ebcdic{},
				},
			}},
			data:    map[string]interface{}{"4f": "032", "02": "24569245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456"},
			want:    bytes.NewBuffer([]byte{0x4f, 0x3, 0xf0, 0xf3, 0xf2, 0x2, 0x81, 0xfe, 0xf2, 0xf4, 0xf5, 0xf6, 0xf9, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6}),
			wantErr: false,
		},
		{
			name: "serialize and deserialize len size three bytes ok",
			taipe: types.BerTLV{Items: []types.Field{
				{
					Name:   "4f",
					SerDes: types.Ebcdic{},
				},
				{
					Name:   "02",
					SerDes: types.Ebcdic{},
				},
			}},
			data:    map[string]interface{}{"4f": "032", "02": "924561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124569245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456124561245612456"},
			want:    bytes.NewBuffer([]byte{0x4f, 0x3, 0xf0, 0xf3, 0xf2, 0x2, 0x82, 0x1, 0xfe, 0xf9, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf9, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6}),
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.taipe.Serialize(tt.data)
			if (err != nil) != tt.wantErr {
				t.Errorf("BerTLV.Serialize() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			assert.Equal(t, tt.want, got)

			if got != nil {
				got2, err := tt.taipe.Deserialize(got)
				if (err != nil) != tt.wantErr {
					t.Errorf("BerTLV.Deserialize() error = %v, wantErr %v", err, tt.wantErr)
					return
				}
				assert.Equal(t, tt.data, got2)
			}
		})
	}
}

func TestBerTLV_ErrorSerialize(t *testing.T) {
	tests := []struct {
		name    string
		data    serdes.Value
		taipe   serdes.Serdes
		want    *bytes.Buffer
		wantErr bool
	}{
		{
			name: "error serialize odd value",
			taipe: types.BerTLV{
				Items: []types.Field{
					{Name: "aa", SerDes: types.Raw{}},
				},
			},
			data:    map[string]interface{}{"aa": "12345"},
			want:    nil,
			wantErr: true,
		},
		{
			name: "error serialize odd tag",
			taipe: types.BerTLV{
				Items: []types.Field{
					{Name: "a", SerDes: types.Raw{}},
				},
			},
			data:    map[string]interface{}{"a": "123456"},
			want:    nil,
			wantErr: true,
		},
		{
			name: "error serialize empty field name",
			taipe: types.BerTLV{
				Items: []types.Field{
					{Name: "", SerDes: types.Raw{}},
				},
			},
			data:    map[string]interface{}{"": "12345"},
			want:    nil,
			wantErr: true,
		},
		{
			name: "error serialize invalid serdes data",
			taipe: types.BerTLV{
				Items: []types.Field{
					{Name: "01", SerDes: types.Raw{}},
				},
			},
			data:    99,
			want:    nil,
			wantErr: true,
		},
		{
			name: "error serialize two tag but only one",
			taipe: types.BerTLV{
				Items: []types.Field{
					{Name: "1f", SerDes: types.Raw{}},
				},
			},
			data:    map[string]interface{}{"1f": "123465"},
			want:    nil,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.taipe.Serialize(tt.data)
			if (err != nil) != tt.wantErr {
				t.Errorf("BerTLV.Serialize() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestBerTLV_ErrorDeserialize(t *testing.T) {
	tests := []struct {
		name    string
		data    *bytes.Buffer
		taipe   serdes.Serdes
		want    serdes.Value
		wantErr bool
	}{
		{
			name: "error deserialize two tag but only one ",
			taipe: types.BerTLV{
				Items: []types.Field{
					{Name: "1f", SerDes: types.Raw{}},
				},
			},
			data:    bytes.NewBuffer([]byte{0x1f, 0x02, 0x00, 0x00}),
			want:    nil,
			wantErr: true,
		},
		{
			name: "continue deserialize invalid field name mapping",
			taipe: types.BerTLV{
				Items: []types.Field{
					{Name: "f", SerDes: types.Raw{}},
				},
			},
			data:    bytes.NewBuffer([]byte{0xf, 0x02, 0x00, 0x00}),
			want:    map[string]interface{}{},
			wantErr: false,
		},
		{
			name: "error deserialize invalid length",
			taipe: types.BerTLV{
				Items: []types.Field{
					{Name: "0f", SerDes: types.Raw{}},
				},
			},
			data:    bytes.NewBuffer([]byte{0x0f, 0x01, 0x00, 0x00}),
			want:    nil,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.taipe.Deserialize(tt.data)
			if (err != nil) != tt.wantErr {
				t.Errorf("BerTLV.Serialize() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestFind(t *testing.T) {
	tests := []struct {
		name string
		tag  int
		p    []byte

		want1      *types.TagValue
		wantErr    bool
		inspectErr func(err error, t *testing.T) //use for more precise error evaluation
	}{
		{
			name:    "decode error",
			tag:     0x2f,
			p:       []byte{0x2f, 0x05, 0x00, 0x00},
			want1:   nil,
			wantErr: true,
		},
		{
			name:    "no tag found",
			tag:     0x2f,
			p:       []byte{0x4f, 0x02, 0x00, 0x00},
			want1:   nil,
			wantErr: true,
			inspectErr: func(err error, t *testing.T) {
				assert.Equal(t, types.ErrTagNotFound, err)
			},
		},
		{
			name:    "tag found",
			tag:     0x4f,
			p:       []byte{0x4f, 0x02, 0x00, 0x00},
			want1:   &types.TagValue{Tag: 0x4f, Value: []byte{0, 0}},
			wantErr: false,
		},
		{
			name:    "tag found recursively",
			tag:     0x4f,
			p:       []byte{0xbf, 0x0c, 0x04, 0x4f, 0x02, 55, 44},
			want1:   &types.TagValue{Tag: 0x4f, Value: []byte{55, 44}},
			wantErr: false,
		},
		{
			name:    "error during recursive search",
			tag:     0x4f,
			p:       []byte{0xbf, 0x0c, 0x04, 0x4f, 0x05, 55, 44},
			want1:   nil,
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got1, err := types.Find(0, tt.tag, tt.p)

			assert.Equal(t, tt.want1, got1, "Find returned unexpected result")

			if tt.wantErr {
				if assert.Error(t, err) && tt.inspectErr != nil {
					tt.inspectErr(err, t)
				}
			} else {
				assert.NoError(t, err)
			}

		})
	}
}
